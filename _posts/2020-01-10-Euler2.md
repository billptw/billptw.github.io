---
title: Euler#2 Even Fibonacci numbers
layout: posts
tags: euler
---

Continuing the [Project Euler Challenge](https://projecteuler.net/), we look at the definitive recursion problem in computer science: dealing with the Fibonacci sequence by summing over even numbers in the sequence for the [second example](https://www.hackerrank.com/contests/projecteuler/challenges/euler002/problem):

## Problem
High level idea: Find the sum of all the even numbers of the Fibonacci sequence below $$N$$.

Input: $$T+1$$ lines of integers. First line contains $$T$$ that denotes the number of test cases. This is followed by $$T$$ lines, each containing an integer, $$N$$. (Note: This is similar to [the previous problem]({% post_url 2020-01-09-Euler1 %}). I have a feeling this is going to be the Hackerrank default template).

Constraints:

$$1 \leq T \leq 10^5$$

$$10 \leq N \leq 4 \times 10^6$$

Note that the value of N begins from 10.

## First thoughts
Let's define the vanilla [Fibonacci sequence](https://en.wikipedia.org/wiki/Fibonacci_number):

$$F_{n} = F_{n-1} + F_{n-2}$$

This means that for each number of the sequence, it is obtained by adding the previous two numbers before it. Here is the first $$10$$ numbers in the sequence:

$$(0),1,2,3,5,8,13,21,34,55,89,\ldots$$

For example, to obtain the fourth number in the sequence $$F_{4}$$, we sum $$2$$ and $$3$$ to obtain $$5$$.

Here is the code implementation of the Fibonnaci sequence in Python:

```python
# naive fibonnaci
def fib(n):
    if n == 1:
        return 1
    elif n == 0:
        return 0
    else:
        return fib(n-1) + fib(n-2)
```

## Recursive Even Fibonacci
Next, we analyse the definition of the Fibonacci sequence. As we are required to obtain the sum of only even-numbered Fibonacci numbers, can we obtain a formula to just calculate said numbers in the sequence?

First, we observe the following lemmas regarding additions of numbers:

*Odd* + **Even** = *Odd*

*Odd* + *Odd* = **Even**

Considering the definition of the Fibonacci sequence being the sum of the previous two numbers, if and only if the previous two numbers are *odd* will the next number be **even**. Based on this findings, our goal is to obtain a formulation of the original Fibonacci number in terms of every third number of the sequence. After working it out for some time, we derived a new formulation for the $$n^{th}$$ number in the even-numbered Fibonacci sequence as follows:

$$F_{n} = 4 \times F_{n-1} + F_{n-2}$$

Expressed in code below:

```python
# recursive even fibonnaci
def fib(n):
    if n == 1:
        return 2
    elif n == 0:
        return 0
    else:
        return 4*fib(n-1) + fib(n-2)
```

Now the solution is starting to take form. Can we further optimize it? What happens when $$N$$ is very large? In this case, our recursive depth stack will hit its limit.

## Iterative Even Fibonacci
To prevent the recursive depth stack error, we create an iterative version of the even fibonacci method. To calculate the preceeding two numbers in the sequence, we save them as variables outside the while loop, which checks if the subsequent calculated value in the sequence is still $$<N$$ before summing to give the answer.

```python
# iterative even fibonacci
def fib(n, store):
    n_minus_2 = 0
    n_minus_1 = 2
    ans = 2
    while n_minus_1 < n:
        old_n_minus_2 = n_minus_1
        n_minus_1 = 4*n_minus_1 + n_minus_2
        n_minus_2 = old_n_minus_2
        if n_minus_1 < n:
            ans += n_minus_1
    print(ans)
```

This concludes today's Euler challenge solution! Futher optimizations can include caching previous calculated Fibonacci numbers, but we leave that for future work.
    
