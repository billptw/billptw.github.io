---
layout: post
title: Euler#1 Multiples of 3 and 5
---

As another year begins, I decided to pick up the [Project Euler Challenge](https://projecteuler.net/). This daily training in computational thinking and debugging will hopefully serve well as 'mental gymming'. Without further ado, let's begin with the [first example](https://www.hackerrank.com/contests/projecteuler/challenges/euler001/problem):

## Problem
High level idea: Find the sum of all the multiples of $$3$$ or $$5$$ below $$N$$.

Input: $$T+1$$ lines of integers. First line contains $$T$$ that denotes the number of test cases. This is followed by $$T$$ lines, each containing an integer, $$N$$.

Constraints:

$$1 \leq T \leq 10^5$$

$$1 \leq N \leq 10^9$$

## First thoughts
First up, let's scope out the frame of the program. We parse the input (assuming only positive real numbers given in constraints, and that the number of lines match $$T+1$$), reading each test case and immediately returning the result.

```python
def get_sum(n):
    # TODO

t = int(input().strip())

for a0 in range(t):
    n = int(input().strip())
    print(get_sum(n))

```

## Naive for-loop count
A first glance, the problem is reminiscent of the [FizzBuzz](https://blog.codinghorror.com/why-cant-programmers-program/) problem commonly used in software engineering interviews. We note that this problem, however, requires us to sum multiples of $$3$$ and $$5$$, and a check for divisibility with either would count multiples of $$15$$ once only. Hence, we're spared from having to deal with the latter case.
```python
def get_sum(n, i=1, val=0):
    while i < n:
        if i%3==0 or i%5==0:
            val+=i
        i+=1
    return val
```
One quick note is the solution is $$\mathcal{O}(N.T)$$ in runtime, where we count up to $$N$$ for each $$T$$ integers. This solution can be very slow if we need to calculate large numbers many times (say, an input of $$\{9999, 10000, 10001\}$$). Is there a way to save previously calculated results?

## For-loop counting with cache
In this implementation, we store each calculated input-value pair into a dictionary. For each additional input, we add the new input into a cached list of previously calculated inputs, checking if the new value is larger than any previously calculated inputs (in decreasing order for efficiency). The trade-off we pay is in storage of input cache as a list and input-value cache as a dictionary takes up $$\mathcal{O}(T)$$ in memory size, as well as additional time required for to sort the list of previous inputs (estimating the python implementation to be $$\mathcal{O}(Tlog(T))$$). However, we greatly save the computation required if $$N >> T$$.

```python
def get_sum(n, i=1, val=0):
    while i < n:
        if i%3==0:
            val+=i
        elif i%5==0:
            val+=i
        i+=1
    return val

t = int(input().strip())

inputs = []
ans_dict = {}

for a0 in range(t):
    n = int(input().strip())
    inputs.insert(0,n)
    inputs.sort(reverse=True)
    i = 0
    while i < len(inputs):
        saved_val = inputs[i]
        if n > saved_val:
            ans = get_sum(n, saved_val, ans_dict.get(saved_val))
            ans_dict[n] = ans
            print(ans)
            break
        elif i == len(inputs)-1:
            ans = get_sum(n)
            ans_dict[n] = ans
            print(ans)
        i+=1
```
Unfortunately, submitting the solution to Hackerrank yields only 60%, failing two of the test cases due to runtime timeout! Is there a more efficient solution around?

## Arithmetic progression
Looking at the requirements of the problem carefully, we are required to return the sum of values subject certain conditions. Can we express the problem as a series of arithmetic progressions (in the form of multiples of values)? Concretely, we can simply calculate the value of a series using the formula below:

$$S_{n}=\frac{n}{2}(2a+(n-1).d)$$, where $$n$$ is the value we wish to sum to,$$a$$ is the first number in the series and $$d$$ is the common difference between numbers in the series. Note that the small $$n$$ in this AP-summation formula differs from our problem's definition of $$N$$ by at least $$1$$, as we are required to sum values up to $$N$$ but not inclusive.

The solution below comprises an addition of two series in multiples of $$3$$ and $$5$$, deducting a series in multiples of $$15$$ to prevent double-counting.

```python
def get_sum(n):
    n = n-1
    sum3 = 0 if n < 3 else int((n - (n%3))/3)
    sum5 = 0 if n < 5 else int((n- (n%5))/5)
    sum15 = 0 if n < 15 else int((n- (n%15))/15)
    return (sum5*(10+(sum5-1)*5) + sum3*(6+(sum3-1)*3) - sum15*(30+(sum15-1)*15))>>1

t = int(input().strip())

for a0 in range(t):
    n = int(input().strip())
    print(get_sum(n))

```
Special note: We do bit-wise manipulation to divide the series by two instead of the normal division. This is because float division leads to large rounding errors during type-casting back to integers when the values are very large, which is well within the constraints of the problem.

It's interesting to see that the most computationally efficient solution ($$\mathcal{O}(1)$$ in runtime) is so concise. Also, solving this problem required thought not just in computing, but mathematical efficiency... looking forward to the other problems in the series!
