---
layout: post
title: Euler#9 Summation of primes
---

High level idea: Find the greatest sum of all primes $$\leq N$$.

Input: $$T+1$$ lines of integers. The input contains $$T$$ in the first line that denotes the number of test cases, followed by $$T$$ lines of integer $$N$$.

Constraints:

$$1 \leq T \leq 10^4$$

$$1 \leq N \leq 10^6$$


## Solution
The first attempt I did was to re-use the prime number generator (naive method) done in [problem #3]({% post_url 2020-01-13-Euler3 %}). Unfortunately, this time round some test cases failed due to too slow an implementation. After some googling, I found a more effective method involving building the [Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes), followed by pre-computing the sum of primes.

The Sieve of Eratosthenes is a boolean array denoting if a number in its index position is prime. For example, sieve[2] should return **True** as $$2$$ is a prime number, whereas sieve[0] and sieve[4] should both return **False**. The algorithm involves first instantiating a boolean array with **True** (except for the first two numbers $$0$$ and $$1$$). Then, starting from $$2$$, we mark out each $$2^{nd}$$ number after $$2$$ until the end of the length of sieve, which basically means we denote each multiple of $$2$$ as not a prime number. We continue this marking of multiples for the next number which has not been marked out: $$3$$ with multiples of $$3$$, skipping $$4$$ which had been marked **False** when sieving out multiples of $$2$$, then sieving multiples of $$5$$, and so on. Code implementation below:

```python
# build sieve where index = prime number
def get_sieve(sieve):
    sieve = [True] * 1000000
    sieve[0] = False
    sieve[1] = False
    i = 2
    while i < len(sieve):
        if sieve[i]:
            j = i
            while i+j < len(sieve):
                sieve[i+j] = False
                j += i
        i += 1
    return sieve
```

With sieve complete, we can finally compute the sum, saving the values in a list indexed by the value of $$N$$ we want to query on.

```python
def sum_prime(sum_primes, sieve):
    sum_primes = [0] * 1000000
    prev = 0
    for i in range(len(sieve)):
        sum_primes[i] = prev
        if sieve[i]:
            sum_primes[i] += i
            prev += i 
    return sum_primes
```

This solution required me to learn something new about prime number generation, where counting can replace division check as s a form of prime number checking. Overall, a fun puzzle to indulge in!
