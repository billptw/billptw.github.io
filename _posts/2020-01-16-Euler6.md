---
layout: post
title: Euler#6 Sum square difference
---

High level idea: Find the absolute difference between the sum of the squares of the first $$N$$ natural numbers and the square of the sum.

Input: $$T+1$$ lines of integers. As always, the first line contains $$T$$ that denotes the number of test cases. This is followed by $$T$$ lines, each containing an integer, $$N$$.

Constraints:

$$1 \leq T \leq 10^4$$

$$1 \leq N \leq 10^4$$


## Solution
This problem requires us to find the difference between the square of a sum and the sum of squares. We break down the problem into two parts: 1) Finding the arithmetic progression up to $$N$$ and squaring the result, and 2) finding the sum of squares.

Sub-problem 1 looks simple: we can easily obtain the arithmetic progression of a number (as done in [the first Euler problem]({% post_url 2020-01-09-Euler1 %})), using the formula $$S_{n}=\frac{n}{2}(2a+(n-1).d)$$. As common difference $$d = 1$$ and first term $$a = 1$$, we can rewrite the formula to $$S_{n}=\frac{n}{2}(n+1)$$. Code implementation below uses bit-shift operation to effectively divide by two without having to type-cast the *float* result back to *int*.

```python
def ap(n):
    return (n * (n+1))>>1
```

For sub-problem 2, it is more time-efficient to save the results of sum of squares in a dictionary, reminiscent of the [previous Euler problem]({% post_url 2020-01-15-Euler5 %}). The calculation of the sum of squares is trivial, with no optimization tricks for this solution.

In the code implementation below, we save a list of sum of squares, *sum_squares*, that satisfies the problem for $$N = $$ *max_n*. We iteratively build up the array up to the maximum value of n we have pre-computed, *max_n*.

```python
def build_arr(n, max_n):
    if max_n < n:
        i = max_n
        while i < n:
            i += 1
            sum_squares[i] = sum_squares[i-1] + i*i
            max_n += 1
        return max_n
```
For the main function, we simply build the array up to the value of $$N$$ we need, and return the difference as required.

```python
t = int(input().strip())
for a0 in range(t):
    n = int(input().strip())
    if max_n < n:
        max_n = build_arr(n, max_n)
    print(ap(n)*ap(n) - sum_squares[n])
```

This solution is rather straight-forward, employing only the AP formula to speed things up. 

## Futher improvements
After a cursory Google search, I found a formula for calculating the sum of squares $$S_{n}=\frac{n}{6}(n+1)(2n+1)$$, which worked like a charm (and is trivial to implement in code):

```python
def ap_sq(n):
    return int((n * (n+1) * (2*n+1))/6)
```

Overall, this problem seeks to train one more so in mathematical thinking than algorithmic optimization.
