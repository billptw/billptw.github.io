---
layout: posts
title: Euler#3 Largest prime factor
tags: euler
---

Continuing the [Project Euler Challenge](https://projecteuler.net/), we look at prime numbers this time round.

## Problem
High level idea: Find the largest prime factor of a given $$N$$.

Input: $$T+1$$ lines of integers. As always, the first line contains $$T$$ that denotes the number of test cases. This is followed by $$T$$ lines, each containing an integer, $$N$$.

Constraints:

$$1 \leq T \leq 10^5$$

$$10 \leq N \leq 10^12$$

Note that the value of N begins from 10.

## First thoughts
One way to tackle the problem is to factorise a given number into its primes and return its largest factor. Prime factorisation is one of the first few lessons taught in secondary school math... it's interesting to get to solve it programmatically now!

A [prime number](https://en.wikipedia.org/wiki/Prime_number) is a natural number greater than $$1$$ that is only divisible by itself and $$1$$. 

Based on that definition,we can iteratively build a list of prime numbers to check if the next number is divisible by any number in our list of primes. We can omit checking divisibility with non-primes (i.e. composite numbers), as divisibility with composite numbers can then be further decomposed into primes, defying the definition of prime numbers.

## Iterative generation
In our solution, we first instantiate a list of primes under the smallest expected input test case, $$10$$. This gives us a list $$\{2,3,5,7\}$$. In the main method *prime_factor*, if we are given $$N$$ greater than the largest value in our generated prime number list *primes*, we run *get_primes* to generate the list of primes $$\leq N$$. Given the full list of primes, we check if the input number is a prime and returning it if so (trivially). Otherwise, we check for divisibility with primes in our list of primes, saving the biggest prime and returning it when the list is exhausted.

```python
def is_prime(n, primes):
    # if n <= primes[-1]:
    #     return True if n in primes else False
    # else:
    sqrt_n = int(math.sqrt(n))
    for prime in primes:
        # prime >= sqrt_n or 
        if n % prime == 0:
            return False
        if prime >= sqrt_n:
            return True
    return True
                
                    
# instantiating with primes under 10
primes = [2, 3, 5, 7]

# build list of primes, biggest prime in list > n
def get_primes(n, primes):
    last = primes[-1]
    while n > primes[-1]:
        last += 2
        if is_prime(last, primes):
            primes.append(last)

def prime_factor(n, primes):
    if n > primes[-1]:
        get_primes(n, primes)
    if n in primes:
        return n
    else:
        biggest_prime = 0
        for prime in primes:
            if n % prime == 0:
                biggest_prime = prime
        return biggest_prime
```

## Better stopping criterion
Next, we improve the speed of the algorithm by using two tricks: Firstly, we reduce the input number as we divide by a divisible prime number, and check to see if the new number is then smaller than the next prime divisor. For the second trick, note that there exists a unique decomposition of a composite number into its primes. This allows us to continue the search for prime division by checking divisibility with primes larger than the previously saved *biggest_prime*. Optimization implemented in code below.

```python
def prime_factor(n, primes):
    if n > primes[-1]:
        get_primes(n, primes)
    if n in primes:
        return n
    else:
        biggest_prime = 0
        i = 0
        while i < len(primes):
            prime = primes[i]
            if prime > n:
                break
            if n % prime == 0:
                biggest_prime = prime
                n /= prime
            i += 1            
        return biggest_prime
```

## Stopping at $$\sqrt{n}$$
To speed things up, we can shorten the search space for checking if a number $$n$$ is a prime by checking for divisibility $$\leq \sqrt{n}$$. Here's why:

If the number $$n$$ is not a prime, it can be expressed into at least two numbers $$a$$ and $$b$$. $$a \geq \sqrt{n} \implies b < \sqrt{n}$$, so finding $$b$$ in that case would suffice to show it is not a prime.

This is expressed in the Python code below:
```python
def is_prime(n, primes):
    # if n <= primes[-1]:
    #     return True if n in primes else False
    # else:
    sqrt_n = int(math.sqrt(n))
    for prime in primes:
        if n % prime == 0:
            return False
        if prime >= sqrt_n:
            return True
    return True
```

Alas, it seems like we are still not fast enough. Is needing to calculate all the prime numbers holding us back?

## No prime cache
In this solution, we borrow the continuous division of input $$n$$ from our better stopping criterion section, but omit the need to check against prime numbers. First, we note the lemma that there exists a unique prime factorisaion for any natural number. Thus, we can contiuously check for divisibility with any natural number starting from 2, reducing our search space by whittling at the number.

In the code implementation below, we first continuously divide the input number by $$2$$ if possible, then do so for $$i = 3, 5, 7, \ldots$$. We check until $$\sqrt{n}$$, returning the result if the final quotient is greater than two (indicating the input value is a prime number), or the saved largest prime.

This solution omits the need to generate prime numbers when we are not required to do so.

```python
def prime_factor(n):
    while n % 2 == 0:
        n = n>>1
    if n == 1:
        return 2
    stop = int(math.sqrt(n))
    prime = 0
    i = 3
    while i <= stop:
        while n % i == 0:
            n = int(n/i)
            prime = i
        i += 2
    return n if n > 2 else prime
```
To be honest, the final solution was obtained from looking up discussion boards, as my initial assumptions that the prime number list is essential was crippling my ability to generate a faster solution. Looking forward, I should overturn my assumptions only calculate values when needed!
