---
title: Euler#5 Smallest multiple
category: posts
tags: euler
published: false
---

High level idea: Find the smallest multiple that is divisible by all integers $$\leq N$$.

Input: $$T+1$$ lines of integers. As always, the first line contains $$T$$ that denotes the number of test cases. This is followed by $$T$$ lines, each containing an integer, $$N$$.

Constraints:

$$1 \leq T \leq 10$$

$$1 \leq N \leq 40$$


## Solution
This problem requires us to find the lowest common multiple of all numbers up to $$N$$.

We can iteratively build the list of prime multiples that satisfies the LCM problem. According to the [fundamental theorem of arithmetic](https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic), for every composite number $$\mathbb{C} \in \{1,\ldots, N \}$$, there exists prime numbers smaller than the composite number which are factors of the composite.

For example, if we have pre-computed the list of prime factors up to $$N = 3$$, our list will look like $$\{2,3\}$$. To produce the LCM of up to $$4$$, we need to add $$2$$ and not $$4$$, as $$4$$ is a composite number that can be factorised into two $$2$$s. Hence, our final list will be $$\{2,3,2\}$$

In the code implementation below, we save a list of prime factors, *factors*, that satisfies the problem for $$N = $$ *max_n*. *num_factors* is a dictionary that gives us the number of prime multiples to multiply over when obtaining the LCM for a given $$N$$. Our algorithm will thus check if each factor in *factors* is a factor of $$N$$, dividing it and storing the new value if so. We then store the final prime remainder into *factors*, updating *num_factors* to include the new value of $$N$$ that we computed.

```python
factors = [1]
num_factors = {1:1}
max_n = 1

def build_arr(n, max_n):
    if max_n < n:
        i = max_n
        while i < n:
            i += 1
            dividend = i
            for divisor in factors:
                if dividend % divisor == 0:
                    dividend /= divisor
            if dividend > 1:
                factors.append(int(dividend))
            num_factors[i] = len(factors)
            max_n += 1
        return max_n
```

We can then multiply over the list of primes to regenerate the LCM. For further time optimization at the cost of memory, we can cache results in a dictionary, which can even be stored as a tuple with our previous *num_factors* dictionary.

```python
def lcm(n):
    i = 0
    ans = 1
    while i < num_factors[n]:
        ans *= factors[i]
        i += 1
    return ans
```
