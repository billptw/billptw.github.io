---
layout: post
title: Euler#4 Largest palindrome product
---

Continuing the [Project Euler Challenge](https://projecteuler.net/), we look at palindromes this today.

## Problem
High level idea: Find the largest palindrome $$<N$$ that is the sum of two three-digit integers.

Input: $$T+1$$ lines of integers. As always, the first line contains $$T$$ that denotes the number of test cases. This is followed by $$T$$ lines, each containing an integer, $$N$$.

Constraints:

$$1 \leq T \leq 100$$

$$101101 \leq N \leq 10^6$$

Note that the value of N begins from 101101.

## First thoughts
Let's understand what a palindrome is. Basically, a [palindromic number](https://en.wikipedia.org/wiki/Palindromic_number) is visually symmetrical, i.e. a number that remains the same when its digits are reversed.

Based on that definition, let's build a simple function that helps us check if a number is a palindrome:

```python
def is_palindrome(n):
    number = str(n)
    i = 0
    while i <= len(number)/2-1:
        if number[i] != number[-1-i]:
            return False
        i += 1
    return True
```

## Prime factorisation
We worked with prime factorisation in the [the previous problem]({% post_url 2020-01-13-Euler3 %}). Can we use the functions we wrote to help solve this problem?

First, let's start with the main loop, which iterates over the range of expected $$N$$ values in decreasing order to check if it is a palindrome. We can then check each palindrome to see if it is a product of two three-digit numbers, returning the palindrome if so.

```python
def main(n):
    i = n-1
    while i >= 101101:
        if is_palindrome(i):
            if factor(i):
                return i
        i -= 1
```

How does prime factorisation come into play? Here is the key idea: We break down each palindrome we find into its primes, we can then check all permutations of multiples of its primes that are under $$1000$$ (to satisfy the three-digit requirement). At the end of it, if we can find up to two such values, then our mission is complete. Here is the attempt in code form:

```python
# prime factorisation
def factor(n):
    factors = []
    while n % 2 == 0:
        n = n>>1
        factors.append(2)
    stop = int(math.sqrt(n))
    i = 3
    while i <= stop:
        while n % i == 0:
            n = int(n/i)
            factors.append(i)
        i += 2
    if n > 2:
        factors.append(n)
        
    for factor in factors:
        if factor > 1000:
            return False

    # print(factors)

    i = 0
    j = len(factors) - 1
    while j > 0:
        val1, val2 = factors[i], factors[j]
        val = val1 * val2
        # print(val1, val2, i, j)
        if val < 1000:
            factors.remove(val1)
            factors.remove(val2)
            factors.append(val)
            if len(factors) == 2:
                return True
            j = len(factors) -1
        j -= 1
    return False
```

